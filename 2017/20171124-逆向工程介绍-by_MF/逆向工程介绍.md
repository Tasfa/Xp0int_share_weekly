#**逆向工程**<br><br>
##来源<br>
逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品**进行逆向分析及研究**，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理。<br><br>
而我们对软件的逆向只是逆向工程的其中一种。被称作：**反向工程**，*Reverse Engineering-RE*.<br><br>
在一篇博客中的解释我觉得是比较合适的：<br>
软件逆向工程（*Software Reverse Engineering*）又称软件反向工程，是指从可运行的程序系统出发，运用解密、反汇编、系统分析、程序理解等多种计算机技术,对软件的结构、流程、算法、代码等进行逆向拆解和分析，推导出软件产品的源代码、设计原理、结构、算法、处理过程、运行方法及相关文档等。通常，人们**把对软件进行反向分析的整个过程统称为软件逆向工程**，**把在这个过程中所采用的技术都统称为软件逆向工程技术**。<br><br>
同时在这篇博客中也提到了：<br>
2007 年 1 月 17 日，最高人民法院发布的第一个涉及不正当竞争案件审理的司法解释明确指出：通过自行开发研制或者**反向工程**等方式获得的商业秘密，将**不被认定为反不正当竞争法**有关条款规定的侵犯商业秘密行为。这样，从法律上也为从事软件逆向工程开发者扫除了最后一道障碍。可以预见，我国的软件逆向工程必将迎来更加辉煌的明天。<br>
#####CTF
涉及Windows/Linux/Android平台的多种编程技术，要求利用常用工具对源代码及二进制文件进行逆向分析，掌握Android移动应用APK文件的逆向分析，掌握加解密、内核编程、算法、反调试和代码混淆技术。 —— 《全国大学生信息安全竞赛参赛指南》<br><br>
<br>
##历史
###20 世纪 60 年代
随着第三代计算机的产生，**为了挽救大量运行在即将报废的第二代计算机上的软件**，同时也为加速开发第三代计算机上的软件，美国开始研制针对特定软件的专门用途的逆编译工具来进行软件移植，并成功转换了许多优秀软件。这些逆编译工具中大量使用了软件逆向工程中的技术方法。此后软件逆向工程技术逐步被各国所认识，并广泛研究和应用到多个软件技术领域中。
### 20 世纪 80 年代，
在国外，*CMU SEI* 成立了专门的再工程中心，致力于通过软件逆向工程进行程序理解技术的标识、增强和实践推广。个人计算机兼容市场爆发性发展的很大一部分原因就是对 *IBM PC* 机的 *BIOS* 软件进行了逆向工程，而芯片制造商 *Cyrix* 和 *AMD* 对 *Intel* 的微处理器进行逆向工程后，开发出了与之相兼容的芯片。<br>
*Chikofs* 等人于 1993 年发起的逆向工程会议每年举行一次，研究和讨论软件逆向工程的问题、技术及其支持工具。大量的研究成果都集中在程序理解的辅助工具上，例如，*IBM* 日本研究员研制的基于知识的代码理解工具 *PROMPTER*、美国 *Yale* 大学计算机系研制的对 *Pascal* 语言进行联机分析和理解的工具 *PROUST* 等。
### 80 年代后期到 90 年代
关于解决软件逆向工程和软件版权的矛盾基本上有了结果，各国纷纷针对软件逆向工程进行立法，不是约束而是规范该领域的研究工作。根据**美国联邦法律**，对拥有版权的软件进行逆向工程操作如反汇编，若不是研制新产品与之竞争或获取非法利益，则所进行的**逆向操作是合法的**[PamelaSamuelson 1990]。**日本也立法规定软件逆向工程是合法的**，理由是它有利于软件应用人员之间的相互交流[[RohanMishral 997],英国政府 1992 年也修改了于1988 年颁布的软件版权法[[SingletonS 1993]，该法律**允许为了研究和个人学习目的而对程序逆向工程**。从此，**逆向工程的研究有了法律保障**。
### 近些年来
国内许多软件公司相继开展了软件逆向工程的研究，针对网络游戏的外挂产业的日益壮大就是软件逆向工程发展的最好见证。电子工业出版社的《加密与解密》等系统丛书，**看雪论坛**等都为我国软件逆向工程的发展作出了贡献。<br><br>（PS：更加详细的历史暂时没有找到）<br><br>
<br>
## 作用
###0x01
由于软件生产技术水平还没有达到人们所期望的程度，**所以从头开发软件已经不适应社会对软件需求的不断增长，为了避免重复劳动，提高软件生产的效率和质量，缓解软件危机，必须充分利用和改造现有软件，**对现有软件进行再设计、再工程，使软件功能得到大幅提高以满足用户的需要，而再设计(*Redesign*)和再工程(*Reengineering*)都是软件逆向工程的形式之一。再工程是指在现有系统基础上，修改系统并组装成新的形式。
###0x02
目前运行的许多系统由于某些原因，例如其**运行环境已改变**，或者是根据业务的需要对其功能要进行**调整**，导致它们必须进行演化才能继续使用。这些系统在经历多年运行之后，包含了众多的知识，包括系统需求、设计决策和业务规则等，通过软件逆向工程将这些软件系统转化为易演化系统，是充分有效地利用这些有用资产的良好途径。**软件逆向工程可以从这些系统的程序源代码出发，导出切实可用的信息。**
###0x03
**在已发布的软件中，许多优秀软件生产厂家出于技术保护等原因没有向用户开放源代码或者不提供源代码，需要用户自己去恢复，此时对软件进行逆向工程研究是最好的方法。**
###0x04
**现今的商业社会把软件科学纳入一种相对封闭的范畴，为了追求利润，一些软件业的霸主试图进行知识的垄断，它的直接体现就是鼓励普通用户和大多数程序员把软件看成“黑箱”，使得它们不去关心软件的运行机制，把软件的生产变成类似车间加工的一道道流程，却隔断了人们深入研究软件科学的通路。而作为开放源代码的前期工程，软件逆向工程对整个开放源代码工程有着至关重要的作用。**
###总结
由此我们看出，软件逆向工程为软件技术的发展和相互学习、借鉴提供了一种很有效的技术手段。<br>
<br><br>
##个人看法
我是从CTF题目中接触到逆向的，最开始是一道投骰子的题目，当初啥都不知道，一次次去试，试了半个小时都没有成功，最后再去看其实OD中实现几个跳转，甚至直接搜索字符串就可以解决了。<br>
到现在做了一些逆向题目，虽然都比较简单，但还是有个大概的思路。
###0x00
判断所需要逆向文件的格式，也就是是什么文件，不同的文件有不同的处理方法。例如非要吧apk拖入OD中，那肯定是不行的。
###0x01
判断程序是否有壳，如果有壳需要脱壳。判断是否有壳，可以使用软件判断，或者自己查看汇编指令看，某些壳有一些特殊的形式。脱壳也可以用脱壳工具直接脱，或者手工脱壳例如：ESP定律等等
###0x02
运行程序，了解程序基本流程是怎么样的。可以记一下那些输出字符串都是什么，方便之后查找字符串。
###0x03
调试程序，可以用IDA，OD，apkkiller等等等等，分析软件中的算法。<br>
（PS：这里是最难的，但是不知道怎么表述，大概就是要知道程序是如何运行的。）
###0x04
知道程序过程之后，找到程序所需要的输入值或程序输出的值，总之就是你需要的东西，通常是写脚本逆向思维求出来。<br><br>
<br>
## 总结
本来就是小白一个，算不上什么总结。说说自己的想法吧，逆向是一条很艰难的路，水很深，需要不断的学习。我自己常去的网站也就是[实验吧](http://www.shiyanbar.com) [i春秋](https://www.ichunqiu.com) [吾爱破解](https://www.52pojie.cn) [看雪学院](https://www.pediy.com) 等等。还要学习的有很多继续学习吧

<br>

此文章引用了 **zoujiajun33** 的博客 [软件逆向工程的前世今生](https://my.oschina.net/zhujian111/blog/865240)